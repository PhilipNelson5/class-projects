\documentclass[11pt]{article}

\usepackage{latexsym}
%\newcommand{\epsfig}{\psfig}
\usepackage{tabularx,booktabs,multirow,delarray,array}
\usepackage{graphicx,amssymb,amsmath,amssymb,mathrsfs}
%\usepackage{hyperref}
\usepackage[linesnumbered, vlined, ruled]{algorithm2e}


%\usepackage[T1]{fontenc}


\aboverulesep=0pt
\belowrulesep=0pt

%\marginparwidth=0in
%\marginparsep=0in
\oddsidemargin=0.0in
\evensidemargin=0.0in
\headheight=0.0in
%\headsep=0in
\topmargin=-0.40in %0.35
\textheight=9.0in %9.1in
\textwidth=6.5in   %6.55in

\usepackage{fullpage}


\begin{document}
\baselineskip=14.0pt

\title{CS5050 \textsc{Advanced Algorithms}
\\{\Large Spring Semester, 2018}
\\ Assignment 2: Divide and Conquer
\\ {\large {\bf Due Date: 3:00 p.m.}, Thursday, Feb. 8, 2018 ({\bf at the beginning of CS5050 class})}}
\date{}
%\date{\today}


\maketitle
%\theoremstyle{plain}\newtheorem{theorem}{\textbf{Theorem}}

\vspace{-0.6in}

\noindent
{\bf Note:} The assignment is much more difficult than Assignment 1, so please start early. As for the last question of Assignment 1, for each of the algorithm design problems in all assignments of this class, you are required to clearly describe the main idea of your algorithm. Although it is not required, you are encouraged to give the pseudo-code (unless you feel it is really not necessary). You also need to briefly explain why your algorithm is correct if the correctness is not that obvious. Finally, please analyze the running time of your algorithm.


\begin{enumerate}



\item
Let $A[1\cdots n]$ be an array of $n$ {\em distinct} numbers (i.e., no two
numbers are equal). If $i<j$ and $A[i]>A[j]$, then the pair
$(A[i],A[j])$ is called an {\em inversion} of $A$.

\begin{enumerate}
\item
	List all inversions of the array $\{ 4,2,9,1,7\}$. {\hfill \bf (5 points)}

\item
	What array with elements from the set $\{1,2,\ldots,n\}$ has the
	most inversions? How many inversions does it have?
	{\hfill \bf (5 points)}

\item
	Give a divide-and-conquer algorithm that computes the number of
	inversions in array $A$ in $O(n\log n)$
	time. ({\bf Hint:} Modify merge sort.)	{\hfill \bf (20 points)}

\end{enumerate}


\item

Let $A[1\ldots n]$ be an array of $n$ elements and $B[1\ldots m]$ another array of $m$ elements, with $m\leq n$. Note that neither $A$ nor $B$ is sorted. The problem is to compute the number of elements of $A$ that are smaller than $B[i]$ for each element $B[i]$ with $1\leq i\leq m$.
For simplicity, we assume that no two elements of $A$ are equal and no two elements of $B$ are equal.

For example, let $A$ be $\{30, 20, 100, 60, 90, 10, 40, 50, 80, 70\}$ of ten elements. Let $B$ be $\{60, 35, 73\}$ of three elements. Then, your answer should be the following: for 60, return 5 (because there 5 numbers in $A$ smaller than 60); for 35, return 3; for 73, return 7.

\begin{enumerate}
\item
Design an $O(n\log n)$ time algorithm for solving the problem. {\hfill \bf (5 points)}

\item
Design an $O(nm)$ time algorithm for the problem. Note that this is better than the $O(n\log n)$ time algorithm if $m<\log n$. {\hfill \bf (5 points)}

\item
Improve your algorithm to $O(n\log m)$ time. Because $m\leq n$, this is better than both the $O(n\log n)$ time and the $O(nm)$ time algorithms. {\hfill \bf (20 points)}


{\bf Hint:} Use the divide and conquer technique. Since $m\leq n$, you cannot sort the array $A$ because that would take $O(n\log n)$ time, which is not $O(n\log m)$ as $m$ may be much smaller than $n$.
\end{enumerate}


{\bf Note:}
You will receive the full 30 points if you give an $O(n\log m)$ time algorithm directly for (c) without giving any algorithms for (a) or (b).


\item
{\bf (20 points)}
Solve the following recurrences (you may use any of the methods we studied in class). Make your bounds as small as possible (in the big-$O$ notation). For each recurrence, $T(n)$ is constant for $n\leq 2$.

\begin{enumerate}

\item
$T(n)=2\cdot T(\frac{n}{2})+ n^3$.

\item
$T(n)=4\cdot T(\frac{n}{2})+n\sqrt{n}$.

\item
$T(n)=2\cdot T(\frac{n}{2})+n\log n$.

\item
$T(n)=T(\frac{3}{4}\cdot n)+n$.
\end{enumerate}

\item
 {\bf (20 points)}
You are consulting for a small computation-intensive investment company, and
they have the following type of problem that they want to solve over and over.
A typical instance of the problem is the following. They are doing a simulation
in which they look at $n$ consecutive days of a given stock, at some point in the past.
Let's number the days $i=1,2,\ldots,n$; for each day $i$, they have a price $p(i)$ per share for the stock on that day. (We'll assume for simplicity that the price was fixed during each day.) Suppose during this time period, they wanted to buy 1000 shares on some day and sell all these shares on some (later) day. They want to know: When should they have bought and when should they have sold in order to have made as much money as possible? (If there was no way to make money during the $n$ days, you should report this instead.)

For example, suppose $n=5$, $p(1)=9$, $p(2)=1$, $p(3)=5$, $p(4)=4$, $p(5)=7$. Then you should return ``buy on $2$, sell on $5$'' (buying on day $2$ and selling on day $5$ means they would have made \$6 per share, the maximum possible for that period).

Clearly, there is a simple algorithm that takes time $O(n^2)$: try all possible pairs of buy/sell days and see which makes them the most money. Your investment friends were hoping for something a little better.

Design an algorithm to solve the problem in $O(n\log n)$ time. Your algorithm should use the divide-and-conquer technique.


{\bf Note:} The divide-and-conquer technique can actually solve the problem in $O(n)$ time. But such an algorithm is not required for this assignment. You may think about it if you would like to challenge yourself.
\end{enumerate}


{\bf Total Points:} 100

\end{document}
